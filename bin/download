#!/usr/bin/env ruby
#/ Usage: download 
#/ Before you have to set environmentvariables RSA_PASSWORD, AUTH_ADMIN_USER, AUTH_ADMIN_PW, FUSE_SHIFT_REMOTE_URL
#/ Downloads and decrypts data from the public fuseShift app.
#/
#/ Options:
#/  -u, --url=URL        public fuseShift app's URL
#/  -k, --key=KEY        path to the private key (defaults to $FUSE_SHIFT_REMOTE_URL or ./fuse_shift.private.pem)
#/  -s, --subset=[WHICH] downloads only a subset of the registrations, WHICH can be email_confirmed, email_not_confirmed or shift_confirmed
$LOAD_PATH << "lib"
require 'base64'
require 'csv'
require 'json'
require 'net/http'
require 'openssl'
require 'uri'
require 'optparse'
require 'fuse_shift_tools/data_manipulation'

# default options
opts = {
  remote_url: ENV["FUSE_SHIFT_REMOTE_URL"] || "http://localhost:3000",
  key_path: './config/development/fuse_shift.private.dev.pem',
  subset: ""
}

ARGV.options do |o|
  o.on("-u", "--url=val") { |val| opts[:remote_url] = val }
  o.on("-k", "--key=val") { |val| opts[:key_path] = val }
  o.on("-s", "--subset=val") {|val| opts[:subset] = val}
  o.on_tail("-h", "--help") { exec "grep ^#/<'#{__FILE__}'|cut -c4-" }
  o.parse!
end


def decrypt(string, opts)
  rsa_private_key = OpenSSL::PKey::RSA.new(File.read(opts[:key_path]), "ruby")
  rsa_private_key.private_decrypt(Base64.strict_decode64(string))
end

def ends_with?(value, string)
  value.to_s[-string.length, string.length] == string
end

def get(opts)
  url = "#{opts[:remote_url]}/registrations"
  if opts[:subset]=="shift_confirmed"
    url+="?shift_confirmed=true"
  elsif opts[:subset]=="email_confirmed"
    url+="?confirmed=true"
  elsif opts[:subset]=="email_not_confirmed"
    url+="?confirmed=false"
  end
  
  uri = URI.parse(url)
  response = Net::HTTP.start(uri.host, uri.port,
    :use_ssl => uri.scheme == 'https') do |http|

    request = Net::HTTP::Get.new(uri.request_uri)
    request.basic_auth 'admin', 'admin'

    response = http.request(request)# Net::HTTPResponse object
    
    response.body
  end
  JSON.parse(response)
end

def normalize(data, opts)
  data.map do |attributes|
    attributes.map do |key, value|
      value = decrypt(value, opts) if ends_with?(value, "==")
      key = "friend"  if key == "is_friend"
      value = value=="1" ? 1 : 0 if ["friend", "german", "english", "french"].include?(key)
      key = 'mobile' if key == 'phonenumber'
      [key, value] unless ['hashed_email'].include?(key)
    end.compact.to_h
  end
end

data = get(opts)
data = normalize(data, opts)
puts DataManipulation.to_csv(data)
  
