#!/usr/bin/env ruby
#/ Downloads and decrypts data from the public fuseShift app.
#/
#/ Usage: download [options]
#/ There is 4 mandatory inputs: either per option (see below) or with environment variables: FS_REMOTE_URL, FS_RSA_PASSWORD, FS_ADMIN_USER, FS_ADMIN_PW
#/
#/ Options:
#/  -s, --subset=[WHICH]          downloads only a subset of the registrations, WHICH can be email_confirmed, email_unconfirmed or shift_confirmed

#/ mandatory if no environmentvariable set:
#/  -u, --url=URL                 web app's URL, defaults to $FS_REMOTE_URL or http://localhost:3000
#/  -k, --rsakey-path=KEYPATH     path to private rsa-key, defaults to $FS_KEYPATH or ./config/development/fuse_shift.private.dev.pem
#/  -p, --rsa-password=PASSWORD   password of rsa-key, defaults to $FS_RSA_PASSWORD
#/  -a, --admin-user=USERNAME     username for admin authentication in web app, defaults to $FS_ADMIN_USER
#/  -w, --admin-password=PW       password for admin authentication in web app, defaults to $FS_ADMIN_PW

$LOAD_PATH << "lib"
require 'base64'
require 'csv'
require 'json'
require 'net/http'
require 'openssl'
require 'uri'
require 'optparse'
require 'fuse_shift_tools/data_manipulation'

# default options
opts = {
  subset: "",
  remote_url: ENV["FS_REMOTE_URL"] || "http://localhost:3000",
  key_path: ENV["FS_KEYPATH"] || './config/development/fuse_shift.private.dev.pem',
  rsa_password: ENV["FS_RSA_PASSWORD"],# || "ruby",
  auth_admin_user: ENV["FS_ADMIN_USER"],
  auth_admin_pw: ENV["FS_ADMIN_PW"],
}



ARGV.options do |o|
  o.on("-u", "--url=val") { |val| opts[:remote_url] = val }
  o.on("-k", "--rsakey-path=val") { |val| opts[:key_path] = val }
  o.on("-p", "--rsa-password=val") { |val| opts[:rsa_password] = val }
  o.on("-s", "--subset=val") {|val| opts[:subset] = val}
  o.on("-a", "--admin-user=val") {|val| opts[:auth_admin_user] = val}
  o.on("-w", "--admin-password=val") {|val| opts[:auth_admin_pw] = val}
  o.on_tail("-h", "--help") { exec "grep ^#/<'#{__FILE__}'|cut -c4-" }
  o.parse!
end

if !opts[:remote_url]
  puts "You need to input the URL of the web app. Either in an environment variable FS_REMOTE_URL or per option -u"
  exit
end
if !opts[:rsa_password]
  puts "you need to input the password for the rsa key. Either in an environment variable FS_RSA_PASSWORD or per option -p"
  exit
end
if !opts[:auth_admin_user]
  puts "you need to input the username of the webapps admin authentication. Either in an environment variable FS_ADMIN_USER or per option -a"
  exit
end
if !opts[:auth_admin_pw]
  puts "you need to input the password of the webapps admin authentication. Either in an environment variable FS_ADMIN_PW or per option -a"
  exit
end

def decrypt(string, opts)
  begin
    keytext = File.read(opts[:key_path])
  rescue  
    puts "you need to input the path to the private rsa-key. Either in an environment variable FS_KEYPATH or per option -k"  
    exit
  end
  rsa_private_key = OpenSSL::PKey::RSA.new(File.read(opts[:key_path]), opts[:rsa_password])
  rsa_private_key.private_decrypt(Base64.strict_decode64(string))
end

def ends_with?(value, string)
  value.to_s[-string.length, string.length] == string
end

def get(opts)
  url = "#{opts[:remote_url]}/registrations"
  if opts[:subset]=="shift_confirmed"
    url+="?shift_confirmed=true"
  elsif opts[:subset]=="email_confirmed"
    url+="?confirmed=true"
  elsif opts[:subset]=="email_unconfirmed"
    url+="?confirmed=false"
  end
  
  uri = URI.parse(url)
  response = Net::HTTP.start(uri.host, uri.port,
    :use_ssl => uri.scheme == 'https') do |http|

    request = Net::HTTP::Get.new(uri.request_uri)
    request.basic_auth(opts[:auth_admin_user], opts[:auth_admin_pw])

    response = http.request(request)# Net::HTTPResponse object
    
    response.body
  end
  JSON.parse(response)
end

def normalize(data, opts)
  data.map do |attributes|
    attributes.map do |key, value|
      value = decrypt(value, opts) if ends_with?(value, "==")
      key = "friend"  if key == "is_friend"
      value = value=="1" ? 1 : 0 if ["friend", "german", "english", "french"].include?(key)
      key = 'mobile' if key == 'phonenumber'
      [key, value] unless ['hashed_email'].include?(key)
    end.compact.to_h
  end
end

data = get(opts)
data = normalize(data, opts)
puts DataManipulation.to_csv(data)
  
